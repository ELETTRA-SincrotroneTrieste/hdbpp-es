// +============================================================================
// $Source:
// /cvsroot/tango-cs/tango/jserver/archiving/ArchivingManager/ArchivingManager.java,v
// $
//
// project : Tango Device Server
//
// Description: java source code for the ArchivingManager class and its
// commands.
// This class is derived from DeviceImpl class.
// It represents the CORBA servant obbject which
// will be accessed from the network. All commands which
// can be executed on the ArchivingManager are implemented
// in this file.
//
// $Author: pierrejoseph $
//
// $Revision: 1.19 $
//
// $Log: ArchivingManager.java,v $
// Revision 1.19 2007/05/11 13:58:16 pierrejoseph
// Attribute addition : release version
//
// Revision 1.18 2007/03/05 16:25:20 ounsy
// non-static DataBase
//
// Revision 1.17 2007/02/26 16:14:24 ounsy
// archiving devices now inherits just from DeviceImpl instead of
// DeviceImplWithShutdownRunnable (they're nonlonger unexported onn shutdown)
//
// Revision 1.16 2007/02/01 13:49:47 pierrejoseph
// minor changes
//
// Revision 1.15 2007/01/05 12:54:47 pierrejoseph
// Modification of the ArchivingMessConfig object creation and so the
// ArchivingStart and ArchivingModif methods argin has been simplified.
//
// Revision 1.14 2006/11/20 09:24:49 ounsy
// minor changes
//
// Revision 1.13 2006/11/13 15:57:37 ounsy
// all java devices now inherit from UnexportOnShutdownDeviceImpl instead of
// from DeviceImpl
//
// Revision 1.12 2006/10/30 14:33:54 ounsy
// modified the ArchivingConfigure command and the init_device method to init
// the HDB and TDB connections separately
//
// Revision 1.11 2006/10/12 06:53:42 chinkumo
// Argin comment modification for the archivingStartHdb command.
// ==>modif pr�c�demment perdue
//
// Revision 1.10 2006/10/11 08:30:32 ounsy
// modified the archiving_start commands to accept the same parameters as
// Archivers
//
// Revision 1.9 2006/10/09 12:53:57 chinkumo
// Argin comment modification for the archivingStartHdb command.
//
// Revision 1.8 2006/01/27 13:06:41 ounsy
// organised imports
//
// Revision 1.7 2005/11/29 17:34:41 chinkumo
// no message
//
// Revision 1.6.10.4 2005/11/29 16:14:07 chinkumo
// Code reformated (pogo compatible)
//
// Revision 1.6.10.3 2005/11/15 13:46:24 chinkumo
// ...
//
// Revision 1.6.10.2 2005/09/26 08:26:57 chinkumo
// Minor changes !
//
// Revision 1.6.10.1 2005/09/16 08:10:22 chinkumo
// The ArchivingManager now use exclusively ArchivingMessConfig object to
// trigger archiving.
//
// Revision 1.6 2005/06/14 10:24:03 chinkumo
// Branch (archivingManager_1_0_1-branch_0) and HEAD merged.
//
// Revision 1.5.4.3 2005/06/13 14:49:04 chinkumo
// The ArchivingManager device was regenerated in Tango V5.
// Changes made to improve the management of exceptions were reported here.
// This class was also modified as some commands now returns a void object
// (ArchivingStartHdb, ArchivingStartTdb, ArchivingStopHdb, ArchivingStopTdb,
// ArchivingModifHdb, ArchivingModifTdb).
//
// Revision 1.5.4.2 2005/05/11 14:46:18 chinkumo
// The ArchivingConfigure's command comment (for documentation ) was corrected.
//
// Revision 1.5.4.1 2005/05/03 16:33:01 chinkumo
// Some constants in the class
// 'fr.soleil.hdbtdbArchivingApi.ArchivingApi.ConfigConst' were renamed. Changes
// reported here.
//
// Revision 1.5 2005/02/04 17:25:19 chinkumo
// The trouble with grouped strategy when launching an archiving sequence was
// fixed.

// The grouped stopping functionnality was reported.
//
// Revision 1.4 2005/01/28 13:11:13 taurel
// Some changes in source files to be Pogo compatible
//
// Revision 1.3 2005/01/26 16:33:33 chinkumo
// Export of the new DServer source code.
//
//
// copyleft : European Synchrotron Radiation Facility
// BP 220, Grenoble 38043
// FRANCE
//
// -============================================================================
//
// This file is generated by POGO
// (Program Obviously used to Generate tango Object)
//
// (c) - Software Engineering Group - ESRF
// =============================================================================

package ArchivingManager;

import org.omg.CORBA.SystemException;
import org.omg.CORBA.UserException;

import fr.esrf.Tango.DevFailed;
import fr.esrf.Tango.DevState;
import fr.esrf.Tango.ErrSeverity;
import fr.esrf.TangoApi.DbDatum;
import fr.esrf.TangoDs.Attribute;
import fr.esrf.TangoDs.DeviceClass;
import fr.esrf.TangoDs.DeviceImpl;
import fr.esrf.TangoDs.Except;
import fr.esrf.TangoDs.TangoConst;
import fr.esrf.TangoDs.Util;
import fr.soleil.commonarchivingapi.ArchivingTools.Tools.GlobalConst;
import fr.soleil.hdbtdbArchivingApi.ArchivingApi.ConfigConst;
import fr.soleil.hdbtdbArchivingApi.ArchivingManagerApi.ArchivingManagerApiRefFactory;
import fr.soleil.hdbtdbArchivingApi.ArchivingManagerApi.IArchivingManagerApiRef;
import fr.soleil.hdbtdbArchivingApi.ArchivingTools.Mode.Mode;
import fr.soleil.hdbtdbArchivingApi.ArchivingTools.Tools.ArchivingException;
import fr.soleil.hdbtdbArchivingApi.ArchivingTools.Tools.ArchivingMessConfig;

/**
 * Class Description: Device of Archiving system <Br>
 * <Br>
 * <br>
 * <b>ROLE</b><br>
 * This DeviceServer is used in order to manage the archiving of exported Tango
 * attributes device. <Br>
 * <Br>
 * <br>
 * <b>ARCHIVING TYPE</b><br>
 * There is two kind of archiving : <Br>
 * <Br>
 * <Li><b>The Historical archiving</b>, manage by HdbArchiver devices.<br>
 * This kind archiving allows to store in a database all the exported tango
 * attributes.<br>
 * It is a continuous and never deleted storage.<br>
 * The frequency use for this kind of storage is usually small. <Br>
 * <Br> <Li><b>The Temporary archiving</b>, manage by TdbArchiver devices.<br>
 * This kind archiving allows to store in a database all the exported tango
 * attributes.<br>
 * The stored values are kept in the database for a limited time
 * ("Keeping Window" [4 hours - 24 hours]). Before being stored into the
 * database, values are first collected into files (timestamp, read value [,
 * write value]). Those files are periodically exported to the database. This
 * export frequency must also be given ("Export Window" [5 seconds - 1 hour]).<br>
 * The frequency use for this kind of storage is usually high. <Br>
 * <Br>
 * <br>
 * <b>ARCHIVING MODE</b><br>
 * An archiving sequence must be tuned to follow one (or several) of the defined
 * archiving modes :<br> <Li>The <b>Periodical mode</b>, this mode allows to
 * archive following a defined frequency.<br> <Li>The <b>Absolute mode</b>, this
 * mode allows to archive a value only if : <br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <var>current_value</var>
 * &gt; <var>previous_archived_value</var> + <var>&delta;<sub>1</sub></var>
 * &nbsp;&nbsp;&nbsp;&nbsp; or <br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <var>current_value</var>
 * &lt; <var>previous_archived_value</var> - <var>&delta;<sub>2</sub></var>.<br>
 * <Li>The <b>Relative mode</b>, this mode allows to archive a value only if :<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <var>current_value</var>
 * &gt; <var>previous_archived_value</var> <var>&micro;<sub>increase</sub></var>
 * &nbsp;&nbsp;&nbsp;&nbsp; or <br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <var>current_value</var>
 * &lt; <var>previous_archived_value</var>
 * <var>&micro;<sub>decrease</sub></var>.<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 * (<var>&micro;<sub>increase</sub></var> and
 * <var>&micro;<sub>decrease</sub></var> are percentages) <Li>The <b>Threshold
 * mode</b>, this mode allows to archive a value only if :<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <var>current_value</var>
 * &gt; <var>threshold_value<sub>sup</sub></var> &nbsp;&nbsp;&nbsp;&nbsp; or <br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <var>current_value</var>
 * &lt; <var>threshold_value<sub>min</sub></var>.<br>
 * (like alarms work).<br>
 * <Br>
 * <Br> <Li>The <b>On Calculation mode</b>, this mode allows to archive
 * according to a user formula.<br> <Li>The <b>On Difference mode</b>, this mode
 * allows to archive when a value changes.<br> <Li>The <b>External mode</b>,
 * this mode allows to archive on the user demand.<br>
 * <br>
 * <br>
 * The 6 last mode must be associated to a periodic mode. <Br>
 * <Br>
 * 
 * @author $Author: pierrejoseph $
 * @version $Revision: 1.19 $
 */

// --------- Start of States Description ----------
/*
 * Device States Description: DevState.ON : The device is ready to use.
 * DevState.RUNNING : The device is executing a command and is not avalaible.
 * DevState.INIT : The device is initializing and still not ready to use.
 * DevState.ALARM : Either one of the two databases (HDB or TDB) is unreachable,
 * or there is no archiver one of them. DevState.FAULT : Either the two
 * databases (HDB and TDB) are unreachable, or there is no archiver at all.
 */
// --------- End of States Description ----------
public class ArchivingManager extends DeviceImpl
/* WithShutdownRunnable */implements TangoConst {

	protected int state;
	private IArchivingManagerApiRef hdbManager, tdbManager;

	private String m_version;

	// --------- Start of attributes data members ----------

	// --------- End of attributes data members ----------

	// --------- Start of properties data members ----------
	/**
	 * Computer identifier on wich is settled the database DB. The identifier
	 * can be the computer name or its IP address. <br>
	 * <b>Default value : </b> hdb
	 */
	String hdbHost;
	/**
	 * Database name.<br>
	 * <b>Default value : </b> hdb
	 */
	String hdbName;

	/**
	 * Computer identifier on wich is settled the database TDB. The identifier
	 * can be the computer name or its IP address. <br>
	 * <b>Default value : </b> tdb
	 */
	String tdbHost;
	/**
	 * Database name.<br>
	 * <b>Default value : </b> tdb
	 */
	String tdbName;

	/**
	 * User identifier (name) used to connect the historical database.
	 */
	String hdbUser;
	/**
	 * Password used to connect the historical database.
	 */
	String hdbPassword;
	/**
	 * User identifier (name) used to connect the temporary database.
	 */
	String tdbUser;
	/**
	 * Password used to connect the temporary database.
	 */
	String tdbPassword;
	/**
	 * true if the ORACLE RAC connection is activated. This information is
	 * appended to all device's (or attributes) name. false otherwise.<br>
	 * <b>Default value : </b> false
	 */
	boolean hdbRacConnection;
	boolean tdbRacConnection;

	// --------- End of properties data members ----------

	// Add your own data members here
	// --------------------------------------

	// =========================================================
	/**
	 * Constructor for simulated Time Device Server.
	 * 
	 * @param cl
	 *            The DeviceClass object
	 * @param s
	 *            The Device name.
	 * @param version
	 *            The device version
	 */
	// =========================================================
	ArchivingManager(DeviceClass cl, String s, String version) throws DevFailed {
		super(cl, s);
		m_version = version;
		init_device();
	}

	// =========================================================
	/**
	 * Constructor for simulated Time Device Server.
	 * 
	 * @param cl
	 *            The DeviceClass object
	 * @param s
	 *            The Device name.
	 * @param d
	 *            Device description.
	 * @param version
	 *            The device version
	 */
	// =========================================================
	ArchivingManager(DeviceClass cl, String s, String d, String version)
			throws DevFailed {
		super(cl, s, d);
		m_version = version;
		init_device();
	}

	// =========================================================
	/**
	 * Initialize the device.
	 */
	// =========================================================
	public void init_device() throws DevFailed {
		System.out.println("ArchivingManager() create " + device_name);

		// Initialise variables to default values
		// -------------------------------------------
		set_state(DevState.INIT);
		set_status(device_name + " : DevState.INIT");
		get_device_property();

		try {
			this.hdbManager = ArchivingManagerApiRefFactory
					.getInstance(ConfigConst.HDB);
			if (hdbName == null)
				this.hdbManager.ArchivingConfigure(hdbUser, hdbPassword);
			else
				this.hdbManager.ArchivingConfigure(hdbHost, hdbName, hdbUser,
						hdbPassword, hdbRacConnection);
		} catch (ArchivingException e) {
			e.printStackTrace();
			get_logger().warn(e.toString(), e);
			// throw e.toTangoException(); CLA 30/10/06 AN EXCEPTION IS NO
			// LONGER THROWN, AS BOTH DATABASES ARE INITIALIZED INDEPENDANTLY
		}
		try {
			this.tdbManager = ArchivingManagerApiRefFactory
					.getInstance(ConfigConst.TDB);
			if (tdbName == null)
				this.tdbManager.ArchivingConfigure(tdbUser, tdbPassword);
			else
				this.tdbManager.ArchivingConfigure(tdbHost, tdbName, tdbUser,
						tdbPassword, tdbRacConnection);
		} catch (ArchivingException e) {
			e.printStackTrace();
			get_logger().warn(e.toString(), e);
			// throw e.toTangoException(); CLA 30/10/06 AN EXCEPTION IS NO
			// LONGER THROWN, AS BOTH DATABASES ARE INITIALIZED INDEPENDANTLY
		}

		boolean db = false;
		boolean al = false;

		if ((al = (hdbManager.getArchiverListSize() == 0 && tdbManager
				.getArchiverListSize() == 0))
				|| (db = !(this.hdbManager.is_db_connected())
						&& !(this.tdbManager.is_db_connected()))) {
			set_state(DevState.FAULT);
			set_status(device_name + " : DevState.FAULT" + "\r\n"
					+ (db ? " No database connected ! " + "\r\n" : "")
					+ (al ? " No archiver available ! " + "\r\n" : ""));
			get_logger().error(
					"ERROR : " + (db ? " - No database connected ! " : "")
							+ (al ? " - No archiver available ! " : ""));
		} else if ((al = (hdbManager.getArchiverListSize() == 0 || tdbManager
				.getArchiverListSize() == 0))
				|| (db = !(this.hdbManager.is_db_connected())
						|| !(this.tdbManager.is_db_connected()))) {
			set_state(DevState.ALARM);
			set_status(device_name
					+ " : DevState.ALARM"
					+ "\r\n"
					+ (db ? " One database (HDB or TDB) is not connected ! "
							+ "\r\n" : "")
					+ (al ? " One kind of archiver is not available ! "
							+ "\r\n" : ""));
			get_logger()
					.warn(
							"WARNING : "
									+ (db ? " - One database is not connected ! "
											: "")
									+ (al ? " - One kind of archiver is not available ! "
											: ""));
		} else {
			System.out.println("ArchivingManager.init_device : READY");
			set_state(DevState.ON);
			set_status(device_name + " : DevState.ON");
		}
	}

	// ===================================================================
	/**
	 * Read the device properties from database.
	 */
	// ===================================================================
	public void get_device_property() throws DevFailed {
		// Initialize your default values here.
		// ------------------------------------------
		hdbUser = ConfigConst.HDB_MANAGER_USER;
		hdbPassword = ConfigConst.HDB_MANAGER_PASSWORD;
		tdbUser = ConfigConst.TDB_MANAGER_USER;
		tdbPassword = ConfigConst.TDB_MANAGER_PASSWORD;

		// Read device properties from database.(Automatic code generation)
		// -------------------------------------------------------------
		if (Util._UseDb == false)
			return;
		String[] propnames = { "HdbHost", "HdbName", "TdbHost", "TdbName",
				"HdbUser", "HdbPassword", "TdbUser", "TdbPassword",
				"HdbRacConnection", "TdbRacConnection" };

		// Call database and extract values
		// --------------------------------------------
		DbDatum[] dev_prop = get_db_device().get_property(propnames);
		ArchivingManagerClass ds_class = (ArchivingManagerClass) get_device_class();
		int i = -1;

		// Extract HDBHost value
		if (dev_prop[++i].is_empty() == false)
			hdbHost = dev_prop[i].extractString();
		else {
			// Try to get value from class property
			DbDatum cl_prop = ds_class.get_class_property(dev_prop[i].name);
			if (cl_prop.is_empty() == false)
				hdbHost = cl_prop.extractString();
		}

		// Extract HDbName value
		if (dev_prop[++i].is_empty() == false)
			hdbName = dev_prop[i].extractString();
		else {
			// Try to get value from class property
			DbDatum cl_prop = ds_class.get_class_property(dev_prop[i].name);
			if (cl_prop.is_empty() == false)
				hdbName = cl_prop.extractString();
		}

		// Extract TDBHost value
		if (dev_prop[++i].is_empty() == false)
			tdbHost = dev_prop[i].extractString();
		else {
			// Try to get value from class property
			DbDatum cl_prop = ds_class.get_class_property(dev_prop[i].name);
			if (cl_prop.is_empty() == false)
				tdbHost = cl_prop.extractString();
		}

		// Extract TDbName value
		if (dev_prop[++i].is_empty() == false)
			tdbName = dev_prop[i].extractString();
		else {
			// Try to get value from class property
			DbDatum cl_prop = ds_class.get_class_property(dev_prop[i].name);
			if (cl_prop.is_empty() == false)
				tdbName = cl_prop.extractString();
		}

		// Extract HdbUser value
		if (dev_prop[++i].is_empty() == false)
			hdbUser = dev_prop[i].extractString();
		else {
			// Try to get value from class property
			DbDatum cl_prop = ds_class.get_class_property(dev_prop[i].name);
			if (cl_prop.is_empty() == false)
				hdbUser = cl_prop.extractString();
		}

		// Extract HdbPassword value
		if (dev_prop[++i].is_empty() == false)
			hdbPassword = dev_prop[i].extractString();
		else {
			// Try to get value from class property
			DbDatum cl_prop = ds_class.get_class_property(dev_prop[i].name);
			if (cl_prop.is_empty() == false)
				hdbPassword = cl_prop.extractString();
		}

		// Extract TdbUser value
		if (dev_prop[++i].is_empty() == false)
			tdbUser = dev_prop[i].extractString();
		else {
			// Try to get value from class property
			DbDatum cl_prop = ds_class.get_class_property(dev_prop[i].name);
			if (cl_prop.is_empty() == false)
				tdbUser = cl_prop.extractString();
		}

		// Extract TdbPassword value
		if (dev_prop[++i].is_empty() == false)
			tdbPassword = dev_prop[i].extractString();
		else {
			// Try to get value from class property
			DbDatum cl_prop = ds_class.get_class_property(dev_prop[i].name);
			if (cl_prop.is_empty() == false)
				tdbPassword = cl_prop.extractString();
		}
		// Extract HdbRacConnection value
		if (dev_prop[++i].is_empty() == false)
			hdbRacConnection = dev_prop[i].extractBoolean();
		else {
			// Try to get value from class property
			DbDatum cl_prop = ds_class.get_class_property(dev_prop[i].name);
			if (cl_prop.is_empty() == false)
				hdbRacConnection = cl_prop.extractBoolean();
		}

		// Extract TdbRacConnection value
		if (dev_prop[++i].is_empty() == false)
			tdbRacConnection = dev_prop[i].extractBoolean();
		else {
			// Try to get value from class property
			DbDatum cl_prop = ds_class.get_class_property(dev_prop[i].name);
			if (cl_prop.is_empty() == false)
				tdbRacConnection = cl_prop.extractBoolean();
		}
		// End of Automatic code generation
		// -------------------------------------------------------------

	}

	// =========================================================
	/**
	 * Method always executed before command execution.
	 */
	// =========================================================
	public void always_executed_hook() {
		get_logger().info("In always_executed_hook method()");
	}

	// =========================================================
	/**
	 * Execute command "State" on device. This command gets the device state
	 * (stored in its <i>device_state</i> data member) and returns it to the
	 * caller.
	 * 
	 * @return State Code
	 */
	// =========================================================
	public DevState dev_state() throws DevFailed {
		DevState argout = super.dev_state();

		get_logger().info("Entering dev_state()");

		// ---Add your Own code to control device here ---

		get_logger().info("Exiting dev_state()");
		return argout;
	}

	// =========================================================
	/**
	 * Execute command "ArchivingConfigure" on device. This command configures
	 * the connection to the historical and temporary databases. It then needs 4
	 * parameters : a login and password for Hdb + a login and password for Tdb
	 * 
	 * @param argin
	 *            <ul>
	 *            <li><var>argin</var>[<code>0</code>], the <em>user name</em>
	 *            used to logg into the historical database.
	 *            <li><var>argin</var>[<code>1</code>], the <em>password</em>
	 *            used to logg into the historical database.
	 *            <li><var>argin</var>[<code>2</code>], the <em>user name</em>
	 *            used to logg into the temporary database.
	 *            <li><var>argin</var>[<code>9</code>], the <em>password</em>
	 *            used to logg into the temporary database.
	 *            </ul>
	 */
	// =========================================================
	public void archiving_configure(String[] argin) throws DevFailed {
		get_logger().info("Entering archiving_configure()");

		// ---Add your Own code to control device here ---
		/*
		 * try { ArchivingManagerApi.ArchivingConfigure(argin[ 0 ] , argin[ 1 ]
		 * , argin[ 2 ] , argin[ 3 ], argin[ 4 ]); } catch ( ArchivingException
		 * e ) { get_logger().warn(e.toString() , e); throw
		 * e.toTangoException(); }
		 */
		boolean needsToThrow = false;

		ArchivingException hdbArchivingException = null;
		try {
			this.hdbManager.ArchivingConfigure(argin[0], argin[1]);
		} catch (ArchivingException e) {
			get_logger().warn(e.toString(), e);
			// throw e.toTangoException(); CLA 30/10/06 AN EXCEPTION IS NO
			// LONGER THROWN, AS BOTH DATABASES ARE INITIALIZED INDEPENDANTLY
			hdbArchivingException = e;
			needsToThrow = true;
		}

		ArchivingException tdbArchivingException = null;
		try {
			this.tdbManager.ArchivingConfigure(argin[2], argin[3]);
		} catch (ArchivingException e) {
			get_logger().warn(e.toString(), e);
			// throw e.toTangoException(); CLA 30/10/06 AN EXCEPTION IS NO
			// LONGER THROWN, AS BOTH DATABASES ARE INITIALIZED INDEPENDANTLY
			tdbArchivingException = e;
			needsToThrow = true;
		}

		/*
		 * if ( hdbArchivingException != null ) { String desc =
		 * "Failed connecting to HDB"; ArchivingException exceptionHDB = new
		 * ArchivingException (message , reason , ErrSeverity.PANIC , desc , ""
		 * ); totale.addStack ( desc, exceptionHDB ); } if (
		 * tdbArchivingException != null ) { String desc =
		 * "Failed connecting to TDB"; ArchivingException exceptionTDB = new
		 * ArchivingException (message , reason , ErrSeverity.PANIC , desc , ""
		 * ); totale.addStack ( desc, exceptionTDB ); }
		 */
		String desc = "";
		if (hdbArchivingException != null) {
			if (tdbArchivingException != null) {
				desc = "Failed connecting to HDB and TDB";
			} else {
				desc = "Failed connecting to HDB";
			}
		} else {
			if (tdbArchivingException != null) {
				desc = "Failed connecting to TDB";
			}
		}

		set_state(DevState.ON);
		set_status(device_name + " : DevState.ON");
		get_logger().info("Exiting archiving_configure()");

		if (needsToThrow) {
			String reason = "Failed while executing ArchivingManager.archiving_configure() method...";
			String message = GlobalConst.ARCHIVING_ERROR_PREFIX + " : ";

			ArchivingException e = new ArchivingException(message, reason,
					ErrSeverity.PANIC, desc, "");
			throw e.toTangoException();
		}
	}

	// =========================================================
	/**
	 * Execute command "ArchivingStartHdb" on device. Start an historical
	 * archiving for the specified attributes, and following the specified mode.
	 * 
	 * @param argin
	 *            Archiving arguments... <BR>
	 *            <blockquote>
	 *            <ul>
	 *            <li><strong>The first part :</strong>
	 *            <ul>
	 *            <li><var>argin</var>[0]<b> =</b> the load balancing type of
	 *            the archiving<br>
	 *            &quot;1&quot;, if all the attribute are archived together in
	 *            the same HdbArchiver device, <br>
	 *            &quot;0&quot; otherwise.
	 *            <li><var>argin</var>[1]<b> =</b> the number of attributes to
	 *            archive<br>
	 *            <li><var>argin</var>[2] to <var>argin</var> [2 +
	 *            <var>argin</var>[1] - 1] = the name of each attribute
	 *            </ul>
	 *            <li><strong>The second part (the <i>Mode </i>part) :</strong>
	 *            <br>
	 *            Let us note <i>&quot;<var>index</var>&quot; </i>the last
	 *            <var>index</var> used (for example, at this point,
	 *            <i><var>index</var></i> = 2]).
	 *            <ul>
	 *            <li><strong>If the Mode is composed of a <i>Periodical
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_P</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the period of the
	 *            periodic mode in (ms)<br>
	 *            <var>index</var> = <var>index</var> + 2<br>
	 *            <li><strong>If the Mode is composed of an <i>Absolute
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_A</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the frequency of the
	 *            <i>absolute mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the delta value max
	 *            when decreasing<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the delta value max
	 *            when increasing<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li><strong>If the Mode is composed of a <i>Relative
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_R</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of the <i>relative mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the <i>decreasing
	 *            variation </i>associated to this mode<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the <i>increasing
	 *            variation </i>associated to this mode<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li><strong>If the Mode is composed of an <i>Threshold
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_T</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the frequency of the
	 *            <i>threshold mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the smallest value
	 *            (min) when decreasing<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the biggest value
	 *            (max) when increasing<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li>If the Mode is composed of a <i>On Calculation
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_C</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of the <i>on calculation mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the <i>number of
	 *            values</i> taken into account<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the <i>type
	 *            </i>associated to this mode<br>
	 *            <var>argin</var>[<var>index</var>+ 5] = Not used at the moment
	 *            <br>
	 *            <var>index</var> = <var>index</var> + 5<br>
	 *            <li><strong>If the Mode is composed of an <i>On Difference
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_D</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of this<i> mode </i>(in ms)<br>
	 *            <var>index</var> = <var>index</var> + 2<br>
	 *            <li><strong>If the Mode is composed of an <i>External
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_E</code><br>
	 *            <var>index</var> = <var>index</var> + 1<br>
	 *            </ul>
	 *            </ul>
	 *            </blockquote>
	 * @see ArchivingMessConfig
	 */
	// =========================================================
	public void archiving_start_hdb(String[] argin) throws DevFailed {
		get_logger().info("Entering archiving_start_hdb()");

		// ---Add your Own code to control device here ---
		set_state(DevState.RUNNING);
		set_status(device_name + " : DevState.RUNNING");

		try {
			ArchivingMessConfig archivingMessConfig = ArchivingMessConfig
					.creationWithoutFullInformation(argin);
			this.hdbManager.ArchivingStart(archivingMessConfig);
		} catch (ArchivingException e) {
			e.printStackTrace();
			get_logger().warn(e.toString(), e);
			throw e.toTangoException();
		}

		set_state(DevState.ON);
		set_status(device_name + " : DevState.ON");
		get_logger().info("Exiting archiving_start_hdb()");
	}

	// =========================================================
	/**
	 * Execute command "ArchivingStartTdb" on device. Start an temporary
	 * archiving for the specified attributes, and following the specified mode.
	 * 
	 * @param argin
	 *            Archiving arguments... <BR>
	 *            <blockquote>
	 *            <ul>
	 *            <li><strong>The first part :</strong>
	 *            <ul>
	 *            <li><var>argin</var>[0]<b> =</b> the load balancing type of
	 *            the archiving<br>
	 *            &quot;1&quot;, if all the attribute are archived together in
	 *            the same HdbArchiver device, <br>
	 *            &quot;0&quot; otherwise.
	 *            <li><var>argin</var>[1]<b> =</b> the number of attributes to
	 *            archive<br>
	 *            <li><var>argin</var>[2] to <var>argin</var> [2 +
	 *            <var>argin</var>[1] - 1] = the name of each attribute
	 *            </ul>
	 *            <li><strong>The second part (the <i>Mode </i>part) :</strong>
	 *            <br>
	 *            Let us note <i>&quot;<var>index</var>&quot; </i>the last
	 *            <var>index</var> used (for example, at this point,
	 *            <i><var>index</var></i> = 2]).
	 *            <ul>
	 *            <li><strong>If the Mode is composed of a <i>Periodical
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_P</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the period of the
	 *            periodic mode in (ms)<br>
	 *            <var>index</var> = <var>index</var> + 2<br>
	 *            <li><strong>If the Mode is composed of an <i>Absolute
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_A</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the frequency of the
	 *            <i>absolute mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the delta value max
	 *            when decreasing<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the delta value max
	 *            when increasing<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li><strong>If the Mode is composed of a <i>Relative
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_R</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of the <i>relative mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the <i>decreasing
	 *            variation </i>associated to this mode<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the <i>increasing
	 *            variation </i>associated to this mode<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li><strong>If the Mode is composed of an <i>Threshold
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_T</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the frequency of the
	 *            <i>threshold mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the smallest value
	 *            (min) when decreasing<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the biggest value
	 *            (max) when increasing<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li>If the Mode is composed of a <i>On Calculation
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_C</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of the <i>on calculation mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the <i>number of
	 *            values</i> taken into account<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the <i>type
	 *            </i>associated to this mode<br>
	 *            <var>argin</var>[<var>index</var>+ 5] = Not used at the moment
	 *            <br>
	 *            <var>index</var> = <var>index</var> + 5<br>
	 *            <li><strong>If the Mode is composed of an <i>On Difference
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_D</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of this<i> mode </i>(in ms)<br>
	 *            <var>index</var> = <var>index</var> + 2<br>
	 *            <li><strong>If the Mode is composed of an <i>External
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_E</code><br>
	 *            <var>index</var> = <var>index</var> + 1<br>
	 *            <li><strong>The Temporary (<i>Intermediate Archiving</i>)
	 *            archiving specific informations </strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>TDB_SPEC</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>export
	 *            frequency </i>(ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the <i>keeping window
	 *            duration </i>in (ms)<br>
	 *            <var>index</var> = <var>index</var> + 3<br>
	 *            </ul>
	 *            </ul>
	 *            </blockquote>
	 * @see ArchivingMessConfig
	 */
	// =========================================================
	public void archiving_start_tdb(String[] argin) throws DevFailed {
		get_logger().info("Entering archiving_start_tdb()");

		// ---Add your Own code to control device here ---
		set_state(DevState.RUNNING);
		set_status(device_name + " : DevState.RUNNING");
		ArchivingMessConfig archivingMessConfig = ArchivingMessConfig
				.creationWithoutFullInformation(argin);
		try {
			this.tdbManager.ArchivingStart(archivingMessConfig);
		} catch (ArchivingException e) {
			get_logger().warn(e.toString(), e);
			throw e.toTangoException();
		}
		set_state(DevState.ON);
		set_status(device_name + " : DevState.ON");
		get_logger().info("Exiting archiving_start_tdb()");
	}

	// =========================================================
	/**
	 * Execute command "ArchivingStopHdb" on device. Stops the historical
	 * archiving for the given attributes.
	 * 
	 * @param argin
	 *            The attribute list.
	 */
	// =========================================================
	public void archiving_stop_hdb(String[] argin) throws DevFailed {
		get_logger().info("Entering archiving_stop_hdb()");

		// ---Add your Own code to control device here ---
		set_state(DevState.RUNNING);
		set_status(device_name + " : DevState.RUNNING");
		try {
			this.hdbManager.ArchivingStopConf(argin);
		} catch (ArchivingException e) {
			get_logger().warn(e.toString(), e);
			throw e.toTangoException();
		}
		set_state(DevState.ON);
		set_status(device_name + " : DevState.ON");
		get_logger().info("Exiting archiving_stop_hdb()");
	}

	// =========================================================
	/**
	 * Execute command "ArchivingStopTdb" on device. Stops the temporary
	 * archiving for the given attributes.
	 * 
	 * @param argin
	 *            The attribute list.
	 */
	// =========================================================
	public void archiving_stop_tdb(String[] argin) throws DevFailed {
		get_logger().info("Entering archiving_stop_tdb()");

		// ---Add your Own code to control device here ---
		set_state(DevState.RUNNING);
		set_status(device_name + " : DevState.RUNNING");
		try {
			this.tdbManager.ArchivingStopConf(argin);
		} catch (ArchivingException e) {
			get_logger().warn(e.toString(), e);
			throw e.toTangoException();
		}
		set_state(DevState.ON);
		set_status(device_name + " : DevState.ON");
		get_logger().info("Exiting archiving_stop_tdb()");
	}

	// =========================================================
	/**
	 * Execute command "ArchivingModifHdb" on device. Change the mode of an
	 * historical archiving.
	 * 
	 * @param argin
	 *            The configuration to switch to... <br>
	 *            <blockquote>
	 *            <ul>
	 *            <li><strong>The first part :</strong>
	 *            <ul>
	 *            <li><var>argin</var>[0]<b> =</b> the load balancing type of
	 *            the archiving<br>
	 *            &quot;1&quot;, if all the attribute are archived together in
	 *            the same TdbArchiver device, <br>
	 *            &quot;0&quot; otherwise.
	 *            <li><var>argin</var>[1]<b> =</b> the number of attributes to
	 *            archive<br>
	 *            <li><var>argin</var>[2] to <var>argin</var> [2 +
	 *            <var>argin</var>[1] - 1] = the name of each attribute
	 *            </ul>
	 *            <li><strong>The second part (the <i>Mode </i>part) :</strong>
	 *            <br>
	 *            Let us note <i>&quot;<var>index</var>&quot; </i>the last
	 *            <var>index</var> used (for example, at this point,
	 *            <i><var>index</var></i> = 2]).
	 *            <ul>
	 *            <li><strong>If the Mode is composed of a <i>Periodical
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_P</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the period of the
	 *            periodic mode in (ms)<br>
	 *            <var>index</var> = <var>index</var> + 2<br>
	 *            <li><strong>If the Mode is composed of an <i>Absolute
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_A</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the frequency of the
	 *            <i>absolute mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the delta value max
	 *            when decreasing<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the delta value max
	 *            when increasing<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li><strong>If the Mode is composed of a <i>Relative
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_R</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of the <i>relative mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the <i>decreasing
	 *            variation </i>associated to this mode<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the <i>increasing
	 *            variation </i>associated to this mode<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li><strong>If the Mode is composed of an <i>Threshold
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_T</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the frequency of the
	 *            <i>threshold mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the smallest value
	 *            (min) when decreasing<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the biggest value
	 *            (max) when increasing<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li>If the Mode is composed of a <i>On Calculation
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_C</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of the <i>on calculation mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the <i>number of
	 *            values</i> taken into account<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the <i>type
	 *            </i>associated to this mode<br>
	 *            <var>argin</var>[<var>index</var>+ 5] = Not used at the moment
	 *            <br>
	 *            <var>index</var> = <var>index</var> + 5<br>
	 *            <li><strong>If the Mode is composed of an <i>On Difference
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_D</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of this<i> mode </i>(in ms)<br>
	 *            <var>index</var> = <var>index</var> + 2<br>
	 *            <li><strong>If the Mode is composed of an <i>External
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_E</code><br>
	 *            <var>index</var> = <var>index</var> + 1<br>
	 *            </ul>
	 *            </ul>
	 *            </blockquote>
	 * @see ArchivingMessConfig
	 */
	// =========================================================
	public void archiving_modif_hdb(String[] argin) throws DevFailed {
		get_logger().info("Entering archiving_modif_hdb()");

		// ---Add your Own code to control device here ---
		set_state(DevState.RUNNING);
		set_status(device_name + " : DevState.RUNNING");
		ArchivingMessConfig archivingMessConfig = ArchivingMessConfig
				.creationWithoutFullInformation(argin);

		try {
			this.hdbManager.ArchivingStopConf(archivingMessConfig
					.getAttributeList());
			archiving_start_hdb(argin);
		} catch (ArchivingException e) {
			get_logger().warn(e.toString(), e);
			throw e.toTangoException();
		}
		set_state(DevState.ON);
		set_status(device_name + " : DevState.ON");
		get_logger().info("Exiting archiving_modif_hdb()");
	}

	// =========================================================
	/**
	 * Execute command "ArchivingModifTdb" on device. Change the mode of a
	 * temporary archiving.
	 * 
	 * @param argin
	 *            The configuration to switch to...... <br>
	 *            <blockquote>
	 *            <ul>
	 *            <li><strong>The first part :</strong>
	 *            <ul>
	 *            <li><var>argin</var>[0]<b> =</b> the load balancing type of
	 *            the archiving<br>
	 *            &quot;1&quot;, if all the attribute are archived together in
	 *            the same TdbArchiver device, <br>
	 *            &quot;0&quot; otherwise.
	 *            <li><var>argin</var>[1]<b> =</b> the number of attributes to
	 *            archive<br>
	 *            <li><var>argin</var>[2] to <var>argin</var> [2 +
	 *            <var>argin</var>[1] - 1] = the name of each attribute
	 *            </ul>
	 *            <li><strong>The second part (the <i>Mode </i>part) :</strong>
	 *            <br>
	 *            Let us note <i>&quot;<var>index</var>&quot; </i>the last
	 *            <var>index</var> used (for example, at this point,
	 *            <i><var>index</var></i> = 2]).
	 *            <ul>
	 *            <li><strong>If the Mode is composed of a <i>Periodical
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_P</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the period of the
	 *            periodic mode in (ms)<br>
	 *            <var>index</var> = <var>index</var> + 2<br>
	 *            <li><strong>If the Mode is composed of an <i>Absolute
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_A</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the frequency of the
	 *            <i>absolute mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the delta value max
	 *            when decreasing<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the delta value max
	 *            when increasing<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li><strong>If the Mode is composed of a <i>Relative
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_R</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of the <i>relative mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the <i>decreasing
	 *            variation </i>associated to this mode<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the <i>increasing
	 *            variation </i>associated to this mode<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li><strong>If the Mode is composed of an <i>Threshold
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_T</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the frequency of the
	 *            <i>threshold mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the smallest value
	 *            (min) when decreasing<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the biggest value
	 *            (max) when increasing<br>
	 *            <var>index</var> = <var>index</var> + 4<br>
	 *            <li>If the Mode is composed of a <i>On Calculation
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_C</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of the <i>on calculation mode </i>in (ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the <i>number of
	 *            values</i> taken into account<br>
	 *            <var>argin</var>[<var>index</var>+ 4] = the <i>type
	 *            </i>associated to this mode<br>
	 *            <var>argin</var>[<var>index</var>+ 5] = Not used at the moment
	 *            <br>
	 *            <var>index</var> = <var>index</var> + 5<br>
	 *            <li><strong>If the Mode is composed of an <i>On Difference
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_D</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>frequency
	 *            </i>of this<i> mode </i>(in ms)<br>
	 *            <var>index</var> = <var>index</var> + 2<br>
	 *            <li><strong>If the Mode is composed of an <i>External
	 *            Mode</i></strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>MODE_E</code><br>
	 *            <var>index</var> = <var>index</var> + 1<br>
	 *            <li><strong>The Temporary (<i>Intermediate Archiving</i>)
	 *            archiving specific informations </strong><br>
	 *            <var>argin</var>[<var>index</var>+ 1] = <code>TDB_SPEC</code><br>
	 *            <var>argin</var>[<var>index</var>+ 2] = the <i>export
	 *            frequency </i>(ms)<br>
	 *            <var>argin</var>[<var>index</var>+ 3] = the <i>keeping window
	 *            duration </i>in (ms)<br>
	 *            <var>index</var> = <var>index</var> + 3<br>
	 *            </ul>
	 *            </ul>
	 *            </blockquote>
	 * @see ArchivingMessConfig
	 */
	// =========================================================
	public void archiving_modif_tdb(String[] argin) throws DevFailed {
		get_logger().info("Entering archiving_modif_tdb()");

		// ---Add your Own code to control device here ---
		set_state(DevState.RUNNING);
		set_status(device_name + " : DevState.RUNNING");
		ArchivingMessConfig archivingMessConfig = ArchivingMessConfig
				.creationWithoutFullInformation(argin);
		try {
			this.tdbManager.ArchivingStopConf(archivingMessConfig
					.getAttributeList());
			archiving_start_tdb(argin);
		} catch (ArchivingException e) {
			get_logger().warn(e.toString(), e);
			throw e.toTangoException();
		}
		set_state(DevState.ON);
		set_status(device_name + " : DevState.ON");
		get_logger().info("Exiting archiving_modif_tdb()");
	}

	// =========================================================
	/**
	 * Execute command "IsArchivedHdb" on device. Check the archiving state
	 * (historical archiving) for each attribute of the given list.
	 * 
	 * @param argin
	 *            The attribute list.
	 * @return For each attribute of the given list...<br>
	 *         <ul>
	 *         <li><code>1</code>, if the attribute is currently being archived
	 *         (historical archiving)
	 *         <li><code>0</code>, otherwise
	 *         </ul>
	 */
	// =========================================================
	public short[] is_archived_hdb(String[] argin) throws DevFailed {
		short[] argout = new short[5];

		get_logger().info("Entering is_archived_hdb()");

		// ---Add your Own code to control device here ---
		boolean result = false;
		argout = new short[argin.length];
		for (int i = 0; i < argin.length; i++) {
			try {
				result = this.hdbManager.isArchived(argin[i]);
			} catch (ArchivingException e) {
				get_logger().warn(e.toString(), e);
				throw e.toTangoException();
			}
			if (result)
				argout[i] = 1;
			else
				argout[i] = 0;
		}
		get_logger().info("Exiting is_archived_hdb()");
		return argout;
	}

	// =========================================================
	/**
	 * Execute command "IsArchivedTdb" on device. Check the archiving state
	 * (temporary archiving) for each attribute of the given list.
	 * 
	 * @param argin
	 *            The attribute list.
	 * @return For each attribute of the given list...<br>
	 *         <ul>
	 *         <li><code>1</code>, if the attribute is currently being archived
	 *         (temporary archiving)
	 *         <li><code>0</code>, otherwise
	 *         </ul>
	 */
	// =========================================================
	public short[] is_archived_tdb(String[] argin) throws DevFailed {
		short[] argout = new short[5];

		get_logger().info("Entering is_archived_tdb()");

		// ---Add your Own code to control device here ---
		boolean result = false;
		argout = new short[argin.length];
		for (int i = 0; i < argin.length; i++) {
			try {
				result = this.tdbManager.isArchived(argin[i]);
			} catch (ArchivingException e) {
				get_logger().warn(e.toString(), e);
				throw e.toTangoException();
			}
			if (result)
				argout[i] = 1;
			else
				argout[i] = 0;
		}
		get_logger().info("Exiting is_archived_tdb()");
		return argout;
	}

	// =========================================================
	/**
	 * Execute command "GetArchivingModeHdb" on device. Return the historical
	 * archiving mode applied to an attribute.
	 * 
	 * @param argin
	 *            The attribute name.
	 * @return The applied mode... <br>
	 *         <blockquote>
	 *         <ul>
	 *         Let us note <i>&quot;<var>index</var>&quot; </i>the last
	 *         <var>index</var> used (for example, at this point,
	 *         <i><var>index</var></i> = 0]).
	 *         <li><strong>If the Mode is composed of a <i>Periodical
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_P</code><br>
	 *         <var>argout</var>[<var>index</var> + 1] = the period of the
	 *         periodic mode in (ms)<br>
	 *         <var>index</var> = <var>index</var> + 2<br>
	 *         <li><strong>If the Mode is composed of an <i>Absolute
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_A</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the frequency of the
	 *         <i>absolute mode </i>in (ms)<br>
	 *         <var>argout</var>[<var>index</var>+ 2] = the delta value max when
	 *         decreasing<br>
	 *         <var>argout</var>[<var>index</var>+ 3] = the delta value max when
	 *         increasing<br>
	 *         <var>index</var> = <var>index</var> + 4<br>
	 *         <li><strong>If the Mode is composed of a <i>Relative
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_R</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the <i>frequency </i>of
	 *         the <i>relative mode </i>in (ms)<br>
	 *         <var>argout</var>[<var>index</var>+ 2] = the <i>decreasing
	 *         variation </i>associated to this mode<br>
	 *         <var>argout</var>[<var>index</var>+ 3] = the <i>increasing
	 *         variation </i>associated to this mode<br>
	 *         <var>index</var> = <var>index</var> + 4<br>
	 *         <li><strong>If the Mode is composed of an <i>Threshold
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_T</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the frequency of the
	 *         <i>threshold mode </i>in (ms)<br>
	 *         <var>argout</var>[<var>index</var>+ 2] = the smallest value (min)
	 *         when decreasing<br>
	 *         <var>argout</var>[<var>index</var>+ 3] = the biggest value (max)
	 *         when increasing<br>
	 *         <var>index</var> = <var>index</var> + 4<br>
	 *         <li>If the Mode is composed of a <i>On Calculation
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_C</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the <i>frequency </i>of
	 *         the <i>on calculation mode </i>in (ms)<br>
	 *         <var>argout</var>[<var>index</var>+ 2] = the <i>number of
	 *         values</i> taken into account<br>
	 *         <var>argout</var>[<var>index</var>+ 3] = the <i>type
	 *         </i>associated to this mode<br>
	 *         <var>argout</var>[<var>index</var>+ 4] = Not used at the moment <br>
	 *         <var>index</var> = <var>index</var> + 5<br>
	 *         <li><strong>If the Mode is composed of an <i>On Difference
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_D</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the <i>frequency </i>of
	 *         this<i> mode </i>(in ms)<br>
	 *         <var>index</var> = <var>index</var> + 2<br>
	 *         <li><strong>If the Mode is composed of an <i>External
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_E</code><br>
	 *         <var>index</var> = <var>index</var> + 1<br>
	 *         </ul>
	 *         </blockquote>
	 */
	// =========================================================
	public String[] get_archiving_mode_hdb(String argin) throws DevFailed {
		String[] argout = new String[5];

		get_logger().info("Entering get_archiving_mode_hdb()");

		// ---Add your Own code to control device here ---
		try {
			Mode mode = (this.hdbManager.GetArchivingMode(argin));
			argout = mode.toArray();
		} catch (ArchivingException e) {
			get_logger().error(e.getMessage());
			throw e.toTangoException();
		}
		get_logger().info("Exiting get_archiving_mode_hdb()");
		return argout;
	}

	// =========================================================
	/**
	 * Execute command "GetArchivingModeTdb" on device. Return the temporary
	 * archiving mode applied to an attribute.
	 * 
	 * @param argin
	 *            The attribute name.
	 * @return The applied mode... <br>
	 *         <blockquote>
	 *         <ul>
	 *         Let us note <i>&quot;<var>index</var>&quot; </i>the last
	 *         <var>index</var> used (for example, at this point,
	 *         <i><var>index</var></i> = 0]).
	 *         <li><strong>If the Mode is composed of a <i>Periodical
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_P</code><br>
	 *         <var>argout</var>[<var>index</var> + 1] = the period of the
	 *         periodic mode in (ms)<br>
	 *         <var>index</var> = <var>index</var> + 2<br>
	 *         <li><strong>If the Mode is composed of an <i>Absolute
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_A</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the frequency of the
	 *         <i>absolute mode </i>in (ms)<br>
	 *         <var>argout</var>[<var>index</var>+ 2] = the delta value max when
	 *         decreasing<br>
	 *         <var>argout</var>[<var>index</var>+ 3] = the delta value max when
	 *         increasing<br>
	 *         <var>index</var> = <var>index</var> + 4<br>
	 *         <li><strong>If the Mode is composed of a <i>Relative
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_R</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the <i>frequency </i>of
	 *         the <i>relative mode </i>in (ms)<br>
	 *         <var>argout</var>[<var>index</var>+ 2] = the <i>decreasing
	 *         variation </i>associated to this mode<br>
	 *         <var>argout</var>[<var>index</var>+ 3] = the <i>increasing
	 *         variation </i>associated to this mode<br>
	 *         <var>index</var> = <var>index</var> + 4<br>
	 *         <li><strong>If the Mode is composed of an <i>Threshold
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_T</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the frequency of the
	 *         <i>threshold mode </i>in (ms)<br>
	 *         <var>argout</var>[<var>index</var>+ 2] = the smallest value (min)
	 *         when decreasing<br>
	 *         <var>argout</var>[<var>index</var>+ 3] = the biggest value (max)
	 *         when increasing<br>
	 *         <var>index</var> = <var>index</var> + 4<br>
	 *         <li>If the Mode is composed of a <i>On Calculation
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_C</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the <i>frequency </i>of
	 *         the <i>on calculation mode </i>in (ms)<br>
	 *         <var>argout</var>[<var>index</var>+ 2] = the <i>number of
	 *         values</i> taken into account<br>
	 *         <var>argout</var>[<var>index</var>+ 3] = the <i>type
	 *         </i>associated to this mode<br>
	 *         <var>argout</var>[<var>index</var>+ 4] = Not used at the moment <br>
	 *         <var>index</var> = <var>index</var> + 5<br>
	 *         <li><strong>If the Mode is composed of an <i>On Difference
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_D</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the <i>frequency </i>of
	 *         this<i> mode </i>(in ms)<br>
	 *         <var>index</var> = <var>index</var> + 2<br>
	 *         <li><strong>If the Mode is composed of an <i>External
	 *         Mode</i></strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>MODE_E</code><br>
	 *         <var>index</var> = <var>index</var> + 1<br>
	 *         <li><strong>The Temporary (<i>Intermediate Archiving</i>)
	 *         archiving specific informations </strong><br>
	 *         <var>argout</var>[<var>index</var>] = <code>TDB_SPEC</code><br>
	 *         <var>argout</var>[<var>index</var>+ 1] = the <i>export frequency
	 *         </i>(ms)<br>
	 *         <var>argout</var>[<var>index</var>+ 2] = the <i>keeping window
	 *         duration </i>in (ms)<br>
	 *         <var>index</var> = <var>index</var> + 3<br>
	 *         </ul>
	 *         </blockquote>
	 */
	// =========================================================
	public String[] get_archiving_mode_tdb(String argin) throws DevFailed {
		String[] argout = new String[5];

		get_logger().info("Entering get_archiving_mode_tdb()");

		// ---Add your Own code to control device here ---
		try {
			Mode mode = (this.tdbManager.GetArchivingMode(argin));
			argout = mode.toArray();
		} catch (ArchivingException e) {
			get_logger().error(e.getMessage());
			throw e.toTangoException();
		}
		get_logger().info("Exiting get_archiving_mode_tdb()");
		return argout;
	}

	// =========================================================
	/**
	 * Execute command "GetStatusHdb" on device. For each attribute of the given
	 * list, get the status of the device in charge of its historical archiving
	 * 
	 * @param argin
	 *            The attribute list.
	 * @return The list of status.
	 */
	// =========================================================
	public String[] get_status_hdb(String[] argin) throws DevFailed {
		String[] argout = new String[5];

		get_logger().info("Entering get_status_hdb()");

		// ---Add your Own code to control device here ---
		set_state(DevState.RUNNING);
		set_status(device_name + " : DevState.RUNNING");
		argout = new String[argin.length];
		for (int i = 0; i < argin.length; i++)
			try {
				argout[i] = this.hdbManager.getStatus(argin[i], true);
			} catch (ArchivingException e) {
				throw e.toTangoException();
			}
		set_state(DevState.ON);
		set_status(device_name + " : DevState.ON");
		get_logger().info("Exiting get_status_hdb()");
		return argout;
	}

	// =========================================================
	/**
	 * Execute command "GetStatusTdb" on device. For each attribute of the given
	 * list, get the status of the device in charge of its temporary archiving.
	 * 
	 * @param argin
	 *            The attribute list.
	 * @return The list of status.
	 */
	// =========================================================
	public String[] get_status_tdb(String[] argin) throws DevFailed {
		String[] argout = new String[5];

		get_logger().info("Entering get_status_tdb()");

		// ---Add your Own code to control device here ---
		set_state(DevState.RUNNING);
		set_status(device_name + " : DevState.RUNNING");
		argout = new String[argin.length];
		for (int i = 0; i < argin.length; i++)
			try {
				argout[i] = this.tdbManager.getStatus(argin[i], false);
			} catch (ArchivingException e) {
				throw e.toTangoException();
			}
		set_state(DevState.ON);
		set_status(device_name + " : DevState.ON");
		get_logger().info("Exiting get_status_tdb()");
		return argout;
	}

	// ===================================================================
	/**
	 * Method called by the read_attributes CORBA operation to set internal
	 * attribute value.
	 * 
	 * @param attr
	 *            reference to the Attribute object
	 */
	// ===================================================================
	public void read_attr(Attribute attr) throws DevFailed {
		String attr_name = attr.get_name();
		get_logger().info("In read_attr for attribute " + attr_name);

		// Switch on attribute name
		// ---------------------------------
		if (attr_name == "version") {
			// Add your own code here
			attr.set_value(m_version);
		}
	}

	// =========================================================
	/**
	 * main part for the device server class
	 */
	// =========================================================
	public static void main(String[] argv) {
		try {
			Util tg = Util.init(argv, "ArchivingManager");
			tg.server_init();

			System.out.println("Ready to accept request");

			tg.server_run();
		} catch (OutOfMemoryError ex) {
			System.err.println("Can't allocate memory !!!!");
			System.err.println("Exiting");
		} catch (UserException ex) {
			Except.print_exception(ex);

			System.err.println("Received a CORBA user exception");
			System.err.println("Exiting");
		} catch (SystemException ex) {
			Except.print_exception(ex);

			System.err.println("Received a CORBA system exception");
			System.err.println("Exiting");
		}

		System.exit(-1);
	}
}

// --------------------------------------------------------------------------
/*
 * end of $Source:
 * /cvsroot/tango-cs/tango/jserver/archiving/ArchivingManager/ArchivingManager
 * .java,v $
 */
